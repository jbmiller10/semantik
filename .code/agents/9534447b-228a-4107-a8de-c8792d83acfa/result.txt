Based on my analysis of the repository, I can now synthesize a comprehensive execution plan for the chunking improvements work. While there is no explicit ENG-002 ticket file, the context is clear from the documentation and branch name (`feature/improve-chunking`).

---

# **ENG-002: Chunking System Improvements - Execution Plan**

## **Executive Summary**

**Objective**: Implement a comprehensive, production-ready chunking system for Semantik with 6 intelligent strategies, supporting 40+ file types, with enhanced architecture based on review feedback.

**Timeline**: 4 weeks (includes buffer)  
**Current Branch**: `feature/improve-chunking`  
**Status**: Active development with architectural improvements in progress

---

## **I. DISCOVERY & CONTEXT WORKSTREAM**

### **Phase 1.1: Codebase Assessment** (0.5 days)

**Objectives**:
- Map existing chunking implementation in `packages/shared/chunking/`
- Identify dependencies on LlamaIndex and sentence-transformers
- Review current database schema for chunks table partitioning
- Assess test coverage baseline

**Key Files to Review**:
- `packages/shared/chunking/` - Current chunking domain logic
- `packages/shared/database/models/` - Chunk and Collection models
- `packages/webui/services/chunking*.py` - Service layer
- `tests/webui/api/v2/test_chunking*.py` - Current test coverage

**Deliverables**:
- ‚úÖ Inventory of current chunking strategies implemented
- ‚úÖ List of gaps vs. target state (6 strategies)
- ‚úÖ Database schema assessment report
- ‚úÖ Test coverage baseline metrics

### **Phase 1.2: Architecture Validation** (0.5 days)

**Objectives**:
- Validate three-layer architecture compliance (API ‚Üí Service ‚Üí Repository)
- Review partition-aware query patterns for chunks table
- Confirm Celery task patterns for async processing
- Validate WebSocket progress tracking implementation

**Key Architecture Points** (from CLAUDE.md):
1. **API Layer** (`packages/webui/api/`) - FastAPI routers only, no business logic
2. **Service Layer** (`packages/webui/services/`) - All business logic
3. **Repository Layer** (`packages/shared/database/repositories/`) - Database access only

**Deliverables**:
- ‚úÖ Architecture compliance report
- ‚úÖ Identified architectural debt to address
- ‚úÖ Validation that chunk queries include `collection_id` (partition pruning)

### **Phase 1.3: Performance Baseline** (1 day)

**Objectives**:
- Establish current performance benchmarks
- Test existing chunking with various document sizes
- Profile memory usage patterns
- Identify bottlenecks

**Test Profiles** (from implementation plan):
```
Hardware Baseline: 4-core CPU, 8GB RAM
Document Sizes: 1KB, 100KB, 10MB, 100MB
```

**Deliverables**:
- ‚úÖ Performance benchmark baseline report
- ‚úÖ Memory usage profiles
- ‚úÖ Bottleneck analysis
- ‚úÖ Target performance metrics documented

---

## **II. IMPLEMENTATION WORKSTREAM**

### **Week 1: Core Foundation & Architecture** üèóÔ∏è

#### **Task 1.1: Base Architecture Implementation** (3 days)

**Priority**: CRITICAL  
**Dependencies**: Phase 1 completion

**Subtasks**:
1. **BaseChunker Interface** (`packages/shared/text_processing/base_chunker.py`)
   - Implement async/sync dual interface
   - Add `ChunkResult` dataclass
   - Add validation methods
   - Add estimation methods

2. **ChunkingService Layer** (`packages/webui/services/chunking_service.py`)
   - Implement business logic separation
   - Add security validation integration
   - Add caching layer (Redis)
   - Add analytics tracking

3. **Core Strategies** (LlamaIndex integration)
   - **CharacterChunker**: TokenTextSplitter wrapper
   - **RecursiveChunker**: SentenceSplitter wrapper (handles code files temporarily)
   - **MarkdownChunker**: MarkdownNodeParser wrapper

4. **Security Validator** (`packages/webui/services/chunking_security.py`)
   - Input validation (chunk size bounds: 50-10,000 characters)
   - Document size limits (100MB max, 1MB for preview)
   - Parameter sanitization
   - Rate limiting integration

**Validation Criteria**:
- ‚úÖ All 3 core strategies pass unit tests
- ‚úÖ Security validator rejects malicious inputs
- ‚úÖ ChunkingService properly delegates to repositories
- ‚úÖ No business logic in API layer

**Files to Create/Modify**:
- `packages/shared/text_processing/base_chunker.py` (NEW)
- `packages/shared/text_processing/chunking_factory.py` (NEW)
- `packages/webui/services/chunking_service.py` (REFACTOR)
- `packages/webui/services/chunking_security.py` (NEW)
- `packages/shared/text_processing/character_chunker.py` (NEW)
- `packages/shared/text_processing/recursive_chunker.py` (NEW)
- `packages/shared/text_processing/markdown_chunker.py` (NEW)

#### **Task 1.2: Error Handling Framework** (1.5 days)

**Priority**: HIGH  
**Dependencies**: Task 1.1

**Subtasks**:
1. **Error Types** (`packages/webui/services/chunking_error_handler.py`)
   - Define `ChunkingErrorType` enum
   - Implement retry strategies
   - Add partial failure handling

2. **Recovery Mechanisms**
   - Graceful degradation on partial failures
   - Checkpoint-based streaming recovery
   - Automatic retry with exponential backoff

3. **Operation Status Management**
   - Update collection status to `DEGRADED` on partial failure
   - Create recovery operations
   - Log comprehensive error details

**Validation Criteria**:
- ‚úÖ Partial failures don't crash entire operation
- ‚úÖ Recovery operations created automatically
- ‚úÖ All error types have defined retry strategies
- ‚úÖ Streaming failures recover from checkpoint

#### **Task 1.3: Performance Testing Framework** (1 day)

**Priority**: HIGH  
**Dependencies**: Tasks 1.1, 1.2

**Subtasks**:
1. **Benchmark Suite** (`tests/performance/chunking_benchmarks.py`)
   - Define performance targets per strategy
   - Create document test profiles (1KB ‚Üí 100MB)
   - Implement memory profiling

2. **Automated Testing**
   - Single-threaded performance tests
   - Parallel processing efficiency tests
   - Memory leak detection

**Performance Targets** (from plan):
```
Character:     1000 chunks/sec (single-thread), 3500 (4-core parallel)
Recursive:     800 chunks/sec (single-thread), 3000 (4-core parallel)
Markdown:      600 chunks/sec (single-thread), 2200 (4-core parallel)
Semantic:      150 chunks/sec (due to embeddings)
Hierarchical:  400 chunks/sec (multiple passes)
```

**Validation Criteria**:
- ‚úÖ Performance tests run in CI/CD
- ‚úÖ Core strategies meet 90% of target benchmarks
- ‚úÖ Memory usage stays under 100MB per 10MB document

#### **Review Checkpoint 1.1: Foundation Validation** (0.5 days)

**CRITICAL DECISION GATE**

**Review Checklist**:
- [ ] BaseChunker interface complete and tested
- [ ] ChunkingService properly separated from API layer
- [ ] Security validation comprehensive
- [ ] Error handling covers all failure modes
- [ ] Performance baseline established
- [ ] Code files handled with recursive chunker

**Decision**:
- üü¢ **Green**: Proceed to Week 2
- üü° **Yellow**: Minor fixes needed (1-2 days slip)
- üî¥ **Red**: Major issues, reassess approach

---

### **Week 2: Advanced Strategies & Integration** üîå

#### **Task 2.1: Advanced Chunking Strategies** (2 days)

**Priority**: HIGH  
**Dependencies**: Week 1 completion

**Subtasks**:
1. **SemanticChunker** (`packages/shared/text_processing/semantic_chunker.py`)
   - Integrate LlamaIndex `SemanticSplitterNodeParser`
   - Use MockEmbedding for tests, OpenAIEmbedding for production
   - Implement async processing (run_in_executor for blocking calls)

2. **HierarchicalChunker** (`packages/shared/text_processing/hierarchical_chunker.py`)
   - Integrate LlamaIndex `HierarchicalNodeParser`
   - Support parent-child chunk relationships
   - Default chunk sizes: [2048, 512, 128]

3. **HybridChunker** (`packages/shared/text_processing/hybrid_chunker.py`)
   - Auto-detect content type (markdown headers, code structure)
   - Switch strategy dynamically
   - Track sub-strategy in metadata

**Validation Criteria**:
- ‚úÖ All 6 strategies implemented
- ‚úÖ Semantic chunker uses mock embeddings in tests
- ‚úÖ Hierarchical chunker preserves parent-child links
- ‚úÖ Hybrid chunker selects appropriate strategy

#### **Task 2.2: Normalized Database Schema** (1.5 days)

**Priority**: HIGH  
**Dependencies**: None (parallel with 2.1)

**Subtasks**:
1. **Migration** (`alembic/versions/XXX_normalized_chunking_schema.py`)
   - Create `chunking_strategies` table
   - Create `chunking_configs` table (with deduplication via `params_hash`)
   - Update `collections` table with `chunking_config_id` FK
   - Create `chunking_history` audit table
   - Create `chunking_metrics` performance tracking table

2. **Partitioning**
   - Implement HASH partitioning on chunks table by `collection_id`
   - Create 16 partitions (increased from current for scale)
   - Add partition-aware indexes

3. **Materialized Views**
   - `collection_stats` view for performance
   - Scheduled refresh function

**Critical**: All chunk queries MUST include `collection_id` for partition pruning

**Validation Criteria**:
- ‚úÖ Migration runs cleanly on test database
- ‚úÖ Partition pruning verified with EXPLAIN ANALYZE
- ‚úÖ Materialized view refreshes without blocking
- ‚úÖ All indexes created and used

**Files to Create**:
- `alembic/versions/XXX_normalized_chunking_schema.py` (NEW)
- `packages/shared/database/models/chunking_strategy.py` (NEW)
- `packages/shared/database/models/chunking_config.py` (NEW)
- `packages/shared/database/repositories/chunking_config_repository.py` (NEW)

#### **Task 2.3: Enhanced API with Security** (2 days)

**Priority**: HIGH  
**Dependencies**: Tasks 2.1, 2.2

**Subtasks**:
1. **New API Endpoints** (`packages/webui/api/v2/chunking.py`)
   - `GET /chunking/strategies` - List available strategies
   - `POST /chunking/preview` - Preview chunking (rate limited: 10/min)
   - `POST /chunking/recommend` - Recommend strategy (rate limited: 20/min)
   - `GET /{collection_id}/chunking/stats` - Detailed statistics
   - `POST /{collection_id}/chunking/validate` - Validate config

2. **WebSock