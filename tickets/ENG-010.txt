Ticket: ENG-010 – Establish Chunking Service Composition Root & Dependency Injection
Phase: 2 – Backend Refactor (Sprints 2–3)
Owner Type: Senior backend engineer familiar with FastAPI dependency wiring and async infrastructure

Repository Context:
- Current consumers (FastAPI routes, Celery tasks) construct `ChunkingService` directly, pulling in DB sessions, Redis clients, cache, metrics, and validators ad hoc.
- Refactored components already exist under `packages/webui/services/chunking/` (e.g., `orchestrator.py`, `processor.py`, `cache.py`, `metrics.py`, `validator.py`) but lack a unified composition root.
- Dependency wiring currently happens in `packages/webui/dependencies.py`, `packages/webui/api/v2/chunking.py`, and `packages/webui/tasks.py` with duplicated instantiation logic.

Problem Statement:
Maintaining manual wiring across API routes and Celery tasks perpetuates tight coupling to the monolithic `ChunkingService`. We need a central place that builds the orchestrator-based architecture introduced during refactor, exposing well-defined factory functions for injection.

Goal:
Create a dependency-injection friendly composition module that assembles chunking services from reusable building blocks. Migrate API dependencies and Celery tasks to request services via the new container, paving the way for deprecating `ChunkingService` monolith.

Implementation Steps:
1. Introduce `packages/webui/services/chunking/container.py` (name flexible) that:
   - Defines factory functions for shared collaborators (e.g., `build_chunking_metrics()`, `build_chunking_cache(...)`, `build_chunking_validator(...)`).
   - Provides a top-level `get_chunking_orchestrator(...)` builder returning `ChunkingOrchestrator` wired with DB session, repositories, cache, metrics, validator, config manager, and processor.
   - Optionally exposes `get_chunking_service_adapter()` that wraps the orchestrator for backward compatibility during migration.
2. Integrate with FastAPI dependencies:
   - Update `packages/webui/dependencies.py` to import from the container instead of instantiating `ChunkingService` directly.
   - Ensure dependency functions respect existing lifetimes (per-request DB session, shared cache, etc.).
3. Update API routes and background tasks:
   - Replace direct `ChunkingService` imports in `packages/webui/api/v2/chunking.py` with calls to the dependency provider.
   - Adjust Celery setup in `packages/webui/tasks.py` to fetch orchestrator/service via container (works for immediate tasks and eventual modularized tasks).
4. Provide toggle/backward compatibility:
   - If parts of the codebase still require `ChunkingService`, create an adapter (see ENG-011) but instantiate it via the container so eventual removal is simplified.
5. Testing & validation:
   - Add unit tests for container functions to ensure they construct objects with expected dependencies (use simple mocks for DB session, Redis, etc.).
   - Execute integration smoke tests hitting chunking API endpoints to ensure DI still works (`uv run pytest tests/webui/services/test_chunking_refactored.py` or equivalent) and Celery tasks can acquire dependencies.
6. Documentation:
   - Document wiring in module docstrings and update developer guides if any exist.

Acceptance Criteria:
- New composition root module exists and is the single entry point for building chunking orchestrator/service objects.
- FastAPI and Celery code paths use the container functions; there is no ad hoc instantiation of `ChunkingService` or orchestrator components elsewhere.
- Tests confirm container wiring and API endpoints continue to function (regression tests pass).
- All repository lint/type/test checks pass (`make lint`, `make type-check`, `make test`).
- Clear path documented for future dependency injection (e.g., enabling test doubles or configuration overrides).

Out of Scope:
- Removing the legacy `ChunkingService` implementation entirely (handled in ENG-011/ENG-012).
- Introducing a third-party DI framework; stick to simple factory functions or lightweight provider pattern.

References:
- packages/webui/dependencies.py (current wiring)
- packages/webui/api/v2/chunking.py (dependency usage)
- packages/webui/tasks.py (Celery dependency wiring)
- packages/webui/services/chunking/orchestrator.py, processor.py, metrics.py, cache.py
