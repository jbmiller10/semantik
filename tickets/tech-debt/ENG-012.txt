Ticket: ENG-012 – Extract Operation Management from ChunkingService
Phase: 2 – Backend Refactor (Sprints 2–3)
Owner Type: Backend engineer experienced with Celery, retry workflows, and state machines

Repository Context:
- `packages/webui/services/chunking_service.py` currently owns retry logic, circuit breaker state, dead-letter queue handling, and resource monitoring across ~hundreds of lines.
- `packages/webui/tasks.py` delegates to these internals, creating a tight coupling between task orchestration and service internals.
- Audit calls out `ChunkingService` as a god object partly due to these responsibilities.

Problem Statement:
Operational concerns (retry strategy, DLQ, circuit breaker) should not live inside the same class that handles chunking business logic. We need a dedicated component (e.g., `ChunkingOperationManager`) responsible for these behaviours, enabling `ChunkingService`/orchestrator to focus on domain operations.

Goal:
Extract operational workflows from `ChunkingService` into a new module, update Celery tasks to depend on it explicitly, and leave the remaining service focused on data processing.

Implementation Steps:
1. Identify operational methods:
   - Circuit breaker fields/methods (`_circuit_breaker_state`, `_update_circuit_breaker_state`, `_check_circuit_breaker`).
   - Dead-letter queue handling (`_send_to_dead_letter_queue`).
   - Retry orchestration, partial failure handling, resource monitoring helpers.
2. Create new module `packages/webui/services/chunking/operation_manager.py` containing:
   - Stateful class encapsulating circuit breaker, retry counts, DLQ publishing, partial failure logging.
   - Dependencies injected (Redis clients, repos, metrics) rather than imported globally.
   - Public methods consumed by Celery tasks and orchestrator.
3. Modify Celery task flow (`packages/webui/tasks.py`):
   - Acquire `OperationManager` through container (ENG-010).
   - Replace direct calls to `ChunkingService` internal helpers with manager methods.
   - Ensure tasks still update Redis progress via ProgressUpdateManager (ENG-001).
4. Trim `ChunkingService`:
   - Remove extracted methods and state. Where necessary, call into `OperationManager` for operations like circuit breaker checks.
   - Ensure dependency graph remains acyclic.
5. Tests:
   - Add unit tests for `OperationManager` covering circuit breaker transitions, DLQ message format, retry count increments, partial failure reporting.
   - Update Celery task tests (or add new ones) verifying tasks respond to circuit breaker state changes and call manager methods.
   - Regression test for DLQ messages to ensure payload format unchanged.
6. Observability:
   - Preserve logging messages and metrics counters (names, labels). If moved, ensure manager emits them.
7. Documentation:
   - Document in code comments how the manager is intended to be used and how state is persisted.

Acceptance Criteria:
- `OperationManager` module exists and `ChunkingService` no longer stores circuit breaker, retry, or DLQ logic internally.
- Celery tasks and other consumers interact with the new manager; no references to removed private methods remain.
- Behaviour of retries, DLQ submissions, and circuit breaker remains identical (validated by tests/log review).
- Quality checks succeed (`make lint`, `make type-check`, `make test`).
- Code is structured for future dependency injection/testing (manager can be mocked or replaced in tests).

Out of Scope:
- Redesigning retry or circuit breaker algorithms; objective is relocation, not re-specification (unless issues surfaced during extraction).

References:
- packages/webui/services/chunking_service.py (search for `_circuit_breaker`, `_send_to_dead_letter_queue`, retry helpers)
- packages/webui/tasks.py (task failure handling, DLQ integration)
- packages/webui/services/chunking_error_handler.py (interactions with operation state)
