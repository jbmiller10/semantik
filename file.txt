diff --git a/apps/webui-react/src/components/EmbeddingVisualizationTab.tsx b/apps/webui-react/src/components/EmbeddingVisualizationTab.tsx
index df0bbfe..515ed28 100644
--- a/apps/webui-react/src/components/EmbeddingVisualizationTab.tsx
+++ b/apps/webui-react/src/components/EmbeddingVisualizationTab.tsx
@@ -5,6 +5,7 @@ import {
   useDeleteProjection,
   useStartProjection,
 } from '../hooks/useProjections';
+import { useProjectionTooltip } from '../hooks/useProjectionTooltip';
 import { useOperationProgress } from '../hooks/useOperationProgress';
 import { projectionsV2Api } from '../services/api/v2/projections';
 import { searchV2Api } from '../services/api/v2/collections';
@@ -19,6 +20,7 @@ import type {
 } from '../types/projection';
 import type { SearchResult } from '../services/api/v2/types';
 import { getErrorMessage } from '../utils/errorUtils';
+import { createCategoryLabels, DEFAULT_CATEGORY_LABEL_OPTIONS } from '../utils/clusterLabels';
 
 const EmbeddingView = lazy(() => import('embedding-atlas/react').then((mod) => ({ default: mod.EmbeddingView })));
 
@@ -62,6 +64,11 @@ const TSNE_METRIC_OPTIONS = ['euclidean'];
 const TSNE_INIT_OPTIONS: Array<'pca' | 'random'> = ['pca', 'random'];
 const SAMPLE_LIMIT_CAP = 200_000;
 
+type RenderMode = 'auto' | 'points' | 'density';
+
+const DENSITY_THRESHOLD = 20_000;
+const RENDER_MODE_OPTIONS: RenderMode[] = ['auto', 'points', 'density'];
+
 const REDUCER_OPTIONS: Array<{
   value: ProjectionReducer;
   label: string;
@@ -118,6 +125,7 @@ export function EmbeddingVisualizationTab({ collectionId }: EmbeddingVisualizati
     pointCount: 0,
     status: 'idle',
   });
+  const [renderModeByProjection, setRenderModeByProjection] = useState<Record<string, RenderMode>>({});
   const [activeProjectionMeta, setActiveProjectionMeta] = useState<{
     color_by?: string;
     legend?: ProjectionLegendItem[];
@@ -126,6 +134,7 @@ export function EmbeddingVisualizationTab({ collectionId }: EmbeddingVisualizati
     total_count?: number;
     degraded?: boolean;
   } | null>(null);
+  const [labelsEnabled, setLabelsEnabled] = useState(false);
   const [selectionState, setSelectionState] = useState<{
     indices: number[];
     items: ProjectionSelectionItem[];
@@ -163,6 +172,11 @@ export function EmbeddingVisualizationTab({ collectionId }: EmbeddingVisualizati
   const startProjection = useStartProjection(collectionId);
   const deleteProjection = useDeleteProjection(collectionId);
   const { setShowDocumentViewer, addToast } = useUIStore();
+  const { tooltipState, handleTooltip, clearTooltipCache } = useProjectionTooltip(
+    collectionId ?? null,
+    activeProjection.projectionId || null,
+    activeProjection.ids
+  );
 
   const { isConnected: isOperationConnected } = useOperationProgress(pendingOperationId, {
     showToasts: false,
@@ -262,6 +276,7 @@ export function EmbeddingVisualizationTab({ collectionId }: EmbeddingVisualizati
     setActiveProjection({ projectionId: projection.id, pointCount: 0, status: 'loading' });
     setActiveProjectionMeta(null);
     setSelectionState({ indices: [], items: [], missing: [], loading: false });
+    clearTooltipCache();
 
     try {
       const metadataResponse = await projectionsV2Api.getMetadata(collectionId, projection.id);
@@ -325,6 +340,7 @@ export function EmbeddingVisualizationTab({ collectionId }: EmbeddingVisualizati
           total_count: parsedTotalCount,
           degraded: metaDegraded,
         });
+        setLabelsEnabled(legendPayload.length > 0);
       }
     } catch (error: unknown) {
       if (requestId === activeRequestId.current) {
@@ -343,6 +359,34 @@ export function EmbeddingVisualizationTab({ collectionId }: EmbeddingVisualizati
     openRecomputeDialog();
   };
 
+  const currentRenderMode: RenderMode = useMemo(() => {
+    if (!activeProjection.projectionId) return 'auto';
+    return renderModeByProjection[activeProjection.projectionId] ?? 'auto';
+  }, [activeProjection.projectionId, renderModeByProjection]);
+
+  const effectiveRenderMode = useMemo<RenderMode>(() => {
+    if (currentRenderMode !== 'auto') {
+      return currentRenderMode;
+    }
+    return activeProjection.pointCount >= DENSITY_THRESHOLD ? 'density' : 'points';
+  }, [currentRenderMode, activeProjection.pointCount]);
+
+  const hasLegend = Boolean(activeProjectionMeta?.legend && activeProjectionMeta.legend.length > 0);
+
+  const clusterLabels = useMemo(() => {
+    if (!labelsEnabled || !activeProjection.arrays || !hasLegend) {
+      return [];
+    }
+    return createCategoryLabels({
+      x: activeProjection.arrays.x,
+      y: activeProjection.arrays.y,
+      category: activeProjection.arrays.category,
+      legend: activeProjectionMeta?.legend ?? [],
+      minPoints: DEFAULT_CATEGORY_LABEL_OPTIONS.minPoints,
+      maxLabels: DEFAULT_CATEGORY_LABEL_OPTIONS.maxLabels,
+    });
+  }, [labelsEnabled, activeProjection.arrays, activeProjectionMeta?.legend, hasLegend]);
+
   const shownCountDisplay = activeProjectionMeta?.shown_count ?? activeProjection.pointCount;
   const totalCountDisplay = activeProjectionMeta?.total_count ?? Math.max(shownCountDisplay, activeProjection.pointCount);
 
@@ -398,6 +442,20 @@ export function EmbeddingVisualizationTab({ collectionId }: EmbeddingVisualizati
     }
   };
 
+  const handleRenderModeChange = (mode: RenderMode) => {
+    if (!activeProjection.projectionId) return;
+    setRenderModeByProjection((prev) => {
+      const existing = prev[activeProjection.projectionId];
+      if (existing === mode) {
+        return prev;
+      }
+      return {
+        ...prev,
+        [activeProjection.projectionId]: mode,
+      };
+    });
+  };
+
   const handleOpenDocument = (item: ProjectionSelectionItem) => {
     if (!item.document_id) {
       addToast({ type: 'error', message: 'No document available to open' });
@@ -814,6 +872,53 @@ export function EmbeddingVisualizationTab({ collectionId }: EmbeddingVisualizati
               )}
             </div>
             <div className="flex flex-col gap-4">
+              <div className="flex flex-wrap items-center justify-between gap-3">
+                <div className="flex flex-wrap items-center gap-2 text-sm text-gray-700">
+                  <span className="font-medium text-gray-800">Rendering</span>
+                  <div className="inline-flex overflow-hidden rounded-md border border-gray-200 bg-white">
+                    {RENDER_MODE_OPTIONS.map((mode) => {
+                      const isActive = currentRenderMode === mode;
+                      const label =
+                        mode === 'auto'
+                          ? 'Auto'
+                          : mode === 'density'
+                            ? 'Density'
+                            : 'Points';
+                      return (
+                        <button
+                          key={mode}
+                          type="button"
+                          onClick={() => handleRenderModeChange(mode)}
+                          className={`px-2.5 py-1 text-xs font-medium transition focus:outline-none focus-visible:ring-2 focus-visible:ring-purple-500 focus-visible:ring-offset-1 ${
+                            isActive
+                              ? 'bg-purple-600 text-white shadow-sm'
+                              : 'text-gray-600 hover:bg-purple-50'
+                          }`}
+                          aria-pressed={isActive}
+                        >
+                          {label}
+                        </button>
+                      );
+                    })}
+                  </div>
+                  <span className="text-xs text-gray-500">
+                    {currentRenderMode === 'auto'
+                      ? `Auto switches to density at ${DENSITY_THRESHOLD.toLocaleString()}+ points`
+                      : `Forced ${currentRenderMode}`}
+                  </span>
+                </div>
+                {hasLegend ? (
+                  <label className="flex items-center gap-2 text-sm text-gray-700">
+                    <input
+                      type="checkbox"
+                      className="h-4 w-4 rounded border-gray-300 text-purple-600 focus:ring-purple-500"
+                      checked={labelsEnabled}
+                      onChange={(event) => setLabelsEnabled(event.target.checked)}
+                    />
+                    Show labels
+                  </label>
+                ) : null}
+              </div>
               {activeProjectionMeta?.color_by && (
                 <div className="flex items-center justify-between">
                   <p className="text-sm text-gray-600">
@@ -867,7 +972,61 @@ export function EmbeddingVisualizationTab({ collectionId }: EmbeddingVisualizati
                   width={viewSize.width}
                   height={viewSize.height}
                   pixelRatio={pixelRatio}
-                  theme={{ statusBar: false }}
+                  theme={{ statusBar: true }}
+                  config={{ mode: effectiveRenderMode }}
+                  labels={labelsEnabled && clusterLabels.length > 0 ? clusterLabels : undefined}
+                  onTooltip={handleTooltip}
+                  customTooltip={({ tooltip }) => {
+                    if (!tooltip) {
+                      return null;
+                    }
+                    const index = (tooltip as { index?: number }).index;
+                    const selectedId =
+                      typeof index === 'number' && activeProjection.ids && index >= 0 && index < activeProjection.ids.length
+                        ? activeProjection.ids[index]
+                        : null;
+                    const metadata =
+                      selectedId !== null && tooltipState.metadata?.selectedId === selectedId
+                        ? tooltipState.metadata
+                        : null;
+                    const status = metadata ? 'success' : tooltipState.status;
+                    if (status === 'idle' && !metadata) {
+                      return null;
+                    }
+                    const documentLabel = metadata?.documentId ?? null;
+                    const chunkLabel = metadata?.chunkIndex ?? null;
+                    const previewText = metadata?.contentPreview?.slice(0, 200) ?? null;
+
+                    return (
+                      <div
+                        role="tooltip"
+                        aria-live="polite"
+                        className="pointer-events-none max-w-xs rounded-md border border-gray-200 bg-white/95 p-2 text-[11px] text-gray-700 shadow-md"
+                      >
+                        {status === 'loading' && !metadata ? (
+                          <div className="text-gray-500">Loading...</div>
+                        ) : null}
+                        {status === 'error' && !metadata ? (
+                          <div className="text-gray-500">No metadata available</div>
+                        ) : null}
+                        {metadata ? (
+                          <div className="space-y-1">
+                            {documentLabel ? (
+                              <div className="font-medium text-gray-800">Document {documentLabel}</div>
+                            ) : null}
+                            {typeof chunkLabel === 'number' ? (
+                              <div className="text-gray-500">Chunk #{chunkLabel}</div>
+                            ) : null}
+                            <div className="text-gray-600">
+                              {previewText && previewText.trim().length > 0
+                                ? previewText
+                                : 'No metadata available'}
+                            </div>
+                          </div>
+                        ) : null}
+                      </div>
+                    );
+                  }}
                   onSelection={(points) => {
                     const indices = Array.isArray(points)
                       ? points
diff --git a/apps/webui-react/src/hooks/useProjectionTooltip.ts b/apps/webui-react/src/hooks/useProjectionTooltip.ts
new file mode 100644
index 0000000..1aa338d
--- /dev/null
+++ b/apps/webui-react/src/hooks/useProjectionTooltip.ts
@@ -0,0 +1,221 @@
+import { useCallback, useEffect, useRef, useState } from 'react';
+import type { DataPoint } from 'embedding-atlas/react';
+import { projectionsV2Api } from '../services/api/v2/projections';
+import { LruCache } from '../utils/lruCache';
+
+type TooltipStatus = 'idle' | 'loading' | 'success' | 'error';
+
+export interface TooltipMetadata {
+  selectedId: number;
+  documentId?: string | number | null;
+  chunkIndex?: number | null;
+  contentPreview?: string | null;
+  source: 'cache' | 'network';
+}
+
+export interface ProjectionTooltipState {
+  status: TooltipStatus;
+  position: { x: number; y: number } | null;
+  metadata: TooltipMetadata | null;
+  error?: string;
+}
+
+export const TOOLTIP_CACHE_SIZE = 512;
+export const TOOLTIP_CACHE_TTL_MS = 60_000;
+export const TOOLTIP_DEBOUNCE_MS = 50;
+export const TOOLTIP_MAX_INFLIGHT = 5;
+
+function toTooltipMetadata(item: any, selectedId: number): TooltipMetadata {
+  const preview = typeof item?.content_preview === 'string' ? item.content_preview.slice(0, 200) : null;
+  return {
+    selectedId,
+    documentId: item?.document_id ?? null,
+    chunkIndex: item?.chunk_index ?? null,
+    contentPreview: preview,
+    source: 'network',
+  };
+}
+
+export function useProjectionTooltip(
+  collectionId: string | null,
+  projectionId: string | null,
+  ids: Int32Array | undefined
+) {
+  const cacheRef = useRef(
+    new LruCache<number, TooltipMetadata>({ max: TOOLTIP_CACHE_SIZE, ttlMs: TOOLTIP_CACHE_TTL_MS })
+  );
+  const debounceTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
+  const latestRequestToken = useRef(0);
+  const inflightTokens = useRef<number[]>([]);
+  const cancelledTokens = useRef<Set<number>>(new Set());
+
+  const [state, setState] = useState<ProjectionTooltipState>({
+    status: 'idle',
+    position: null,
+    metadata: null,
+  });
+
+  const clearState = useCallback(() => {
+    setState({ status: 'idle', position: null, metadata: null });
+  }, []);
+
+  useEffect(() => {
+    cacheRef.current.clear();
+    cancelledTokens.current.clear();
+    inflightTokens.current = [];
+    if (debounceTimerRef.current) {
+      clearTimeout(debounceTimerRef.current);
+      debounceTimerRef.current = null;
+    }
+    clearState();
+  }, [projectionId, clearState]);
+
+  const scheduleFetch = useCallback(
+    (point: DataPoint & { index: number }) => {
+      if (!collectionId || !projectionId || !ids) {
+        setState({
+          status: 'error',
+          position: { x: point.x, y: point.y },
+          metadata: null,
+          error: 'No metadata available',
+        });
+        return;
+      }
+
+      const pointIndex = point.index;
+      if (pointIndex < 0 || pointIndex >= ids.length) {
+        setState({
+          status: 'error',
+          position: { x: point.x, y: point.y },
+          metadata: null,
+          error: 'No metadata available',
+        });
+        return;
+      }
+
+      const selectedId = ids[pointIndex];
+      if (typeof selectedId !== 'number' || Number.isNaN(selectedId)) {
+        setState({
+          status: 'error',
+          position: { x: point.x, y: point.y },
+          metadata: null,
+          error: 'No metadata available',
+        });
+        return;
+      }
+
+      const cached = cacheRef.current.get(selectedId);
+      if (cached) {
+        setState({
+          status: 'success',
+          position: { x: point.x, y: point.y },
+          metadata: { ...cached, source: 'cache' },
+        });
+        return;
+      }
+
+      setState({
+        status: 'loading',
+        position: { x: point.x, y: point.y },
+        metadata: null,
+      });
+
+      const token = ++latestRequestToken.current;
+      inflightTokens.current.push(token);
+      if (inflightTokens.current.length > TOOLTIP_MAX_INFLIGHT) {
+        const dropped = inflightTokens.current.shift();
+        if (typeof dropped === 'number') {
+          cancelledTokens.current.add(dropped);
+        }
+      }
+
+      void projectionsV2Api
+        .select(collectionId, projectionId, [selectedId])
+        .then((response) => {
+          if (
+            cancelledTokens.current.has(token) ||
+            latestRequestToken.current !== token
+          ) {
+            return;
+          }
+
+          const item = response.data?.items?.[0];
+          const metadata = toTooltipMetadata(item, selectedId);
+          cacheRef.current.set(selectedId, { ...metadata, source: 'network' });
+          setState({
+            status: 'success',
+            position: { x: point.x, y: point.y },
+            metadata,
+          });
+        })
+        .catch(() => {
+          if (cancelledTokens.current.has(token)) {
+            return;
+          }
+          cacheRef.current.set(selectedId, {
+            selectedId,
+            documentId: null,
+            chunkIndex: null,
+            contentPreview: null,
+            source: 'network',
+          });
+          setState({
+            status: 'error',
+            position: { x: point.x, y: point.y },
+            metadata: null,
+            error: 'No metadata available',
+          });
+        })
+        .finally(() => {
+          cancelledTokens.current.delete(token);
+          inflightTokens.current = inflightTokens.current.filter((t) => t !== token);
+        });
+    },
+    [collectionId, projectionId, ids]
+  );
+
+  const handleTooltip = useCallback(
+    (value: DataPoint | null) => {
+      if (debounceTimerRef.current) {
+        clearTimeout(debounceTimerRef.current);
+        debounceTimerRef.current = null;
+      }
+
+      if (!value) {
+        clearState();
+        return;
+      }
+
+      const point = value as DataPoint & { index?: number };
+      if (typeof point.index !== 'number') {
+        setState({
+          status: 'error',
+          position: { x: point.x, y: point.y },
+          metadata: null,
+          error: 'No metadata available',
+        });
+        return;
+      }
+
+      debounceTimerRef.current = setTimeout(() => {
+        scheduleFetch({ ...point, index: point.index });
+      }, TOOLTIP_DEBOUNCE_MS);
+    },
+    [clearState, scheduleFetch]
+  );
+
+  const handleTooltipLeave = useCallback(() => {
+    if (debounceTimerRef.current) {
+      clearTimeout(debounceTimerRef.current);
+      debounceTimerRef.current = null;
+    }
+    clearState();
+  }, [clearState]);
+
+  return {
+    tooltipState: state,
+    handleTooltip,
+    handleTooltipLeave,
+    clearTooltipCache: () => cacheRef.current.clear(),
+  };
+}
diff --git a/apps/webui-react/src/utils/__tests__/clusterLabels.test.ts b/apps/webui-react/src/utils/__tests__/clusterLabels.test.ts
new file mode 100644
index 0000000..7a752f1
--- /dev/null
+++ b/apps/webui-react/src/utils/__tests__/clusterLabels.test.ts
@@ -0,0 +1,94 @@
+import { describe, expect, it } from 'vitest';
+import { createCategoryLabels } from '../clusterLabels';
+import type { ProjectionLegendItem } from '../../types/projection';
+
+describe('createCategoryLabels', () => {
+  it('computes centroids and sorts by cluster size', () => {
+    const x = new Float32Array([0, 1, 2, 10, 11, 12, 20, 21, 22]);
+    const y = new Float32Array([0, 0, 0, 5, 5, 5, 10, 10, 10]);
+    const category = new Uint8Array([0, 0, 0, 1, 1, 1, 2, 2, 2]);
+    const legend: ProjectionLegendItem[] = [
+      { index: 0, label: 'Alpha', count: 3 },
+      { index: 1, label: 'Beta', count: 3 },
+      { index: 2, label: 'Gamma', count: 3 },
+    ];
+
+    const labels = createCategoryLabels({
+      x,
+      y,
+      category,
+      legend,
+      minPoints: 3,
+      maxLabels: 5,
+    });
+
+    expect(labels).toHaveLength(3);
+    expect(labels[0].text).toBe('Alpha');
+    expect(labels[0].x).toBeCloseTo(1);
+    expect(labels[1].text).toBe('Beta');
+    expect(labels[2].text).toBe('Gamma');
+  });
+
+  it('filters out clusters below the minimum threshold', () => {
+    const x = new Float32Array([0, 1, 10, 11, 50]);
+    const y = new Float32Array([0, 0, 5, 5, 12]);
+    const category = new Uint8Array([0, 0, 1, 1, 2]);
+    const legend: ProjectionLegendItem[] = [
+      { index: 0, label: 'Keep', count: 2 },
+      { index: 1, label: 'Also Keep', count: 2 },
+      { index: 2, label: 'Drop', count: 1 },
+    ];
+
+    const labels = createCategoryLabels({
+      x,
+      y,
+      category,
+      legend,
+      minPoints: 2,
+      maxLabels: 5,
+    });
+
+    expect(labels).toHaveLength(2);
+    expect(labels.every((label) => label.text !== 'Drop')).toBe(true);
+  });
+
+  it('enforces maximum label count', () => {
+    const categoryCount = 60;
+    const pointsPerCategory = 10;
+    const totalPoints = categoryCount * pointsPerCategory;
+    const x = new Float32Array(totalPoints);
+    const y = new Float32Array(totalPoints);
+    const category = new Uint8Array(totalPoints);
+    const legend: ProjectionLegendItem[] = [];
+
+    for (let i = 0; i < categoryCount; i += 1) {
+      legend.push({ index: i, label: `Cluster ${i}`, count: pointsPerCategory });
+      for (let j = 0; j < pointsPerCategory; j += 1) {
+        const idx = i * pointsPerCategory + j;
+        x[idx] = i * 2;
+        y[idx] = i * 2;
+        category[idx] = i;
+      }
+    }
+
+    const labels = createCategoryLabels({
+      x,
+      y,
+      category,
+      legend,
+      minPoints: 5,
+      maxLabels: 50,
+    });
+
+    expect(labels.length).toBeLessThanOrEqual(50);
+  });
+
+  it('returns empty array when lengths mismatch or legend missing', () => {
+    const x = new Float32Array([0, 1]);
+    const y = new Float32Array([0, 0]);
+    const category = new Uint8Array([0]);
+
+    expect(createCategoryLabels({ x, y, category, legend: [], minPoints: 1, maxLabels: 5 })).toEqual([]);
+  });
+});
+
diff --git a/apps/webui-react/src/utils/__tests__/lruCache.test.ts b/apps/webui-react/src/utils/__tests__/lruCache.test.ts
new file mode 100644
index 0000000..f16047a
--- /dev/null
+++ b/apps/webui-react/src/utils/__tests__/lruCache.test.ts
@@ -0,0 +1,52 @@
+import { describe, expect, it, beforeEach, afterEach, vi } from 'vitest';
+import { LruCache } from '../lruCache';
+
+describe('LruCache', () => {
+  beforeEach(() => {
+    vi.useFakeTimers();
+  });
+
+  afterEach(() => {
+    vi.useRealTimers();
+  });
+
+  it('returns values that were set', () => {
+    const cache = new LruCache<string, number>({ max: 2, ttlMs: 1_000 });
+    cache.set('a', 1);
+    expect(cache.get('a')).toBe(1);
+  });
+
+  it('evicts least recently used entries when capacity exceeded', () => {
+    const cache = new LruCache<string, number>({ max: 2, ttlMs: 5_000 });
+    cache.set('a', 1);
+    cache.set('b', 2);
+    // Access `a` so `b` becomes least recently used.
+    expect(cache.get('a')).toBe(1);
+    cache.set('c', 3);
+
+    expect(cache.get('a')).toBe(1);
+    expect(cache.get('b')).toBeUndefined();
+    expect(cache.get('c')).toBe(3);
+  });
+
+  it('expires entries after TTL', () => {
+    const cache = new LruCache<string, number>({ max: 5, ttlMs: 1_000 });
+    cache.set('token', 42);
+    expect(cache.get('token')).toBe(42);
+
+    vi.advanceTimersByTime(1_001);
+    expect(cache.get('token')).toBeUndefined();
+  });
+
+  it('reports current size', () => {
+    const cache = new LruCache<string, number>({ max: 3, ttlMs: 5_000 });
+    cache.set('a', 1);
+    cache.set('b', 2);
+    cache.set('c', 3);
+    expect(cache.size).toBe(3);
+
+    cache.set('d', 4); // evicts the oldest entry
+    expect(cache.size).toBe(3);
+  });
+});
+
diff --git a/apps/webui-react/src/utils/clusterLabels.ts b/apps/webui-react/src/utils/clusterLabels.ts
new file mode 100644
index 0000000..2317333
--- /dev/null
+++ b/apps/webui-react/src/utils/clusterLabels.ts
@@ -0,0 +1,111 @@
+import type { ProjectionLegendItem } from '../types/projection';
+
+export interface CategoryLabel {
+  x: number;
+  y: number;
+  text: string;
+  level?: number;
+  priority?: number;
+}
+
+interface CreateCategoryLabelsParams {
+  x: Float32Array;
+  y: Float32Array;
+  category: Uint8Array;
+  legend?: ProjectionLegendItem[];
+  minPoints?: number;
+  maxLabels?: number;
+}
+
+const DEFAULT_MIN_POINTS = 8;
+const DEFAULT_MAX_LABELS = 50;
+
+export const DEFAULT_CATEGORY_LABEL_OPTIONS = {
+  minPoints: DEFAULT_MIN_POINTS,
+  maxLabels: DEFAULT_MAX_LABELS,
+} as const;
+
+export function createCategoryLabels({
+  x,
+  y,
+  category,
+  legend,
+  minPoints = DEFAULT_MIN_POINTS,
+  maxLabels = DEFAULT_MAX_LABELS,
+}: CreateCategoryLabelsParams): CategoryLabel[] {
+  const pointCount = x.length;
+  if (pointCount === 0 || y.length !== pointCount || category.length !== pointCount) {
+    return [];
+  }
+
+  if (!legend || legend.length === 0) {
+    return [];
+  }
+
+  const legendMap = new Map<number, string>();
+  for (const item of legend) {
+    if (typeof item.index === 'number' && item.label) {
+      legendMap.set(item.index, item.label);
+    }
+  }
+
+  if (legendMap.size === 0) {
+    return [];
+  }
+
+  const minPointsThreshold = Math.max(1, Math.floor(minPoints));
+  const maxLabelCount = Math.max(1, Math.floor(maxLabels));
+
+  const accumulators = new Map<number, { count: number; sumX: number; sumY: number }>();
+
+  for (let i = 0; i < pointCount; i += 1) {
+    const catIndex = category[i];
+    const label = legendMap.get(catIndex);
+    if (!label) {
+      continue;
+    }
+
+    const current = accumulators.get(catIndex);
+    if (current) {
+      current.count += 1;
+      current.sumX += x[i];
+      current.sumY += y[i];
+    } else {
+      accumulators.set(catIndex, {
+        count: 1,
+        sumX: x[i],
+        sumY: y[i],
+      });
+    }
+  }
+
+  const labels: CategoryLabel[] = [];
+
+  for (const [catIndex, stats] of accumulators) {
+    if (stats.count < minPointsThreshold) {
+      continue;
+    }
+
+    const labelText = legendMap.get(catIndex);
+    if (!labelText) {
+      continue;
+    }
+
+    labels.push({
+      x: stats.sumX / stats.count,
+      y: stats.sumY / stats.count,
+      text: labelText,
+      level: 1,
+      priority: stats.count,
+    });
+  }
+
+  if (labels.length <= maxLabelCount) {
+    return labels.sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));
+  }
+
+  return labels
+    .sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0))
+    .slice(0, maxLabelCount);
+}
+
diff --git a/apps/webui-react/src/utils/lruCache.ts b/apps/webui-react/src/utils/lruCache.ts
new file mode 100644
index 0000000..1da5b56
--- /dev/null
+++ b/apps/webui-react/src/utils/lruCache.ts
@@ -0,0 +1,87 @@
+type LruEntry<V> = {
+  value: V;
+  expiresAt: number | null;
+};
+
+export interface LruCacheOptions {
+  /** Maximum number of entries retained at once. */
+  max: number;
+  /** Optional TTL in milliseconds for each entry. */
+  ttlMs?: number;
+}
+
+/**
+ * Simple TTL-aware LRU cache backed by Map insertion order.
+ * Evicts the least recently used entry when capacity is exceeded.
+ */
+export class LruCache<K, V> {
+  private readonly store = new Map<K, LruEntry<V>>();
+
+  private readonly max: number;
+
+  private readonly ttlMs: number | null;
+
+  constructor(options: LruCacheOptions) {
+    if (!options || typeof options.max !== 'number' || options.max <= 0) {
+      throw new Error('LruCache requires a positive `max` option');
+    }
+    this.max = Math.floor(options.max);
+    this.ttlMs = typeof options.ttlMs === 'number' && options.ttlMs > 0 ? options.ttlMs : null;
+  }
+
+  get size(): number {
+    return this.store.size;
+  }
+
+  get(key: K): V | undefined {
+    const existing = this.store.get(key);
+    if (!existing) {
+      return undefined;
+    }
+
+    if (this.isExpired(existing)) {
+      this.store.delete(key);
+      return undefined;
+    }
+
+    // Re-insert to update iteration order (most recently used moves to end).
+    this.store.delete(key);
+    this.store.set(key, existing);
+    return existing.value;
+  }
+
+  set(key: K, value: V): void {
+    if (this.store.has(key)) {
+      this.store.delete(key);
+    } else if (this.store.size >= this.max) {
+      this.evictLeastRecentlyUsed();
+    }
+
+    const expiresAt = this.ttlMs === null ? null : Date.now() + this.ttlMs;
+    this.store.set(key, { value, expiresAt });
+  }
+
+  delete(key: K): void {
+    this.store.delete(key);
+  }
+
+  clear(): void {
+    this.store.clear();
+  }
+
+  private isExpired(entry: LruEntry<V>): boolean {
+    if (entry.expiresAt === null) {
+      return false;
+    }
+    return entry.expiresAt <= Date.now();
+  }
+
+  private evictLeastRecentlyUsed(): void {
+    const iterator = this.store.keys();
+    const oldestKey = iterator.next().value;
+    if (oldestKey !== undefined) {
+      this.store.delete(oldestKey);
+    }
+  }
+}
+
