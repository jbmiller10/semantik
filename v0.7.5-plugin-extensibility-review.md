# v0.7.5 Plugin Extensibility Branch - Comprehensive Review Report

**Date:** January 2, 2026
**Branch:** v0.7.5
**Base:** main
**Reviewer:** Claude Code (Automated Multi-Agent Review)
**Follow-up Verification:** GPT-5.2 (Codex CLI) — double-checked against the current `v0.7.5` working tree on January 2, 2026
**Scope:** 104 files changed, ~17,500 lines added

---

## Executive Summary

The v0.7.5 branch implements a comprehensive plugin extensibility system for Semantik, adding support for embedding, chunking, connector, reranker, and extractor plugins. The implementation is architecturally sound with good separation of concerns and a cooperative security model. This document was originally generated by an automated review; it has been **updated after a manual double-check** to remove non-reproducible findings and reflect the current code.

### Overall Assessment: **B+** (Good with Notable Improvements Needed)

| Category | Grade | Summary |
|----------|-------|---------|
| Architecture | A | Well-designed plugin system with clear interfaces |
| Thread Safety | B+ | Good use of locks; no confirmed registry race conditions on re-check |
| Security | B | Cooperative model appropriate; input validation exists but can be tightened |
| API Design | A- | RESTful and well-documented; install/uninstall are globally rate-limited, but could use stricter per-endpoint limits |
| Frontend | B | Good UX; app-level error boundary exists; key remaining concerns are test quality and hardening edge cases |
| Testing | B- | Good coverage, over-mocking concerns |
| Documentation | B | Comprehensive but some inaccuracies |
| Database | A- | Clean migrations, missing validation |

### Key Issues (Confirmed on Re-Check)

1. **Potential unbounded growth in `ExtractorService` instance cache** - Cache of extractor instances has no eviction
2. **No schema/size validation for `extraction_config`** - Stored/accepted as arbitrary JSON (risk is malformed data + runtime errors, not SQL injection)
3. **Extractor test endpoint missing a request size limit** - Accepts arbitrarily large text payloads
4. **Install target validation too permissive** - `pip install <target>` validation doesn't restrict local paths / `file://` / unsupported schemes
5. **Phase 7 status incorrectly marked as "Planned"** in roadmap (implementation exists)

---

## Table of Contents

1. [Plugin Infrastructure Core](#1-plugin-infrastructure-core)
2. [Reranker and Extractor Types](#2-reranker-and-extractor-types)
3. [Backend API Endpoints](#3-backend-api-endpoints)
4. [Frontend Implementation](#4-frontend-implementation)
5. [Security Implementation](#5-security-implementation)
6. [Registry and Plugin Installation](#6-registry-and-plugin-installation)
7. [Database and Integration](#7-database-and-integration)
8. [Documentation](#8-documentation)
9. [Frontend Test Quality](#9-frontend-test-quality)
10. [Recommendations Summary](#10-recommendations-summary)

---

## 1. Plugin Infrastructure Core

**Files Reviewed:** `packages/shared/plugins/` (loader.py, registry.py, state.py, validation.py)

### Strengths

- **Thread-safe registry** using `RLock` for concurrent access protection
- **Idempotent loading** with proper skip-if-loaded checks
- **Unified plugin model** supporting 5 plugin types with adapters
- **Clean separation** between plugin definition and runtime state
- **Entry point discovery** using Python's standard mechanism

### Issues / Notes

#### 1.1 `PluginRegistry.list_records()` Race Condition (NOT REPRODUCED)

**File:** `packages/shared/plugins/registry.py`

On re-check, the reported implementation and risk do not match the current code:

- `PluginRecord` is `@dataclass(frozen=True)` and `list_records()` returns a snapshot list built under an `RLock`.
- The previously referenced “mutable `PluginInfo` objects” do not exist in the current registry implementation.

Current `list_records()` shape (simplified):

```python
def list_records(
    self,
    *,
    plugin_type: str | None = None,
    source: PluginSource | None = None,
) -> list[PluginRecord]:
    with self._lock:
        ...
    if source is not None:
        records = [record for record in records if record.source == source]
    return records
```

**Remaining caveat:** `PluginManifest` is frozen, but `manifest.capabilities` is a `dict` and therefore still mutable if a caller mutates it. Core code does not mutate it, so this is currently a *hardening/immutability* consideration rather than a demonstrated race.

#### 1.2 State File Atomicity (ALREADY IMPLEMENTED)

**File:** `packages/shared/plugins/state.py`

State file writes already use a temp file + atomic rename strategy (and best-effort `chmod` hardening). The original “non-atomic write” finding was not reproducible against the current code.

#### 1.3 Double-Registration Risk (LOW)

**File:** `packages/shared/plugins/loader.py`

**Confirmed:** With `include_builtins=True` and `include_external=True`, built-in providers/strategies can be registered both via the “built-ins” path *and* via internal entry points declared under the same `semantik.plugins` group. The registry treats this as an idempotent duplicate and skips it, but it’s extra work and can confuse logs/reasoning.

**Recommendation:** Recompute `missing` after loading built-ins, or skip internal modules when iterating entry points (or split internal vs external entry point groups).

### Missing Test Coverage

- `state.py` - No unit tests for state persistence
- `validation.py` - No unit tests despite being security-critical
- Edge cases for concurrent plugin loading

---

## 2. Reranker and Extractor Types

**Files Reviewed:** `packages/shared/plugins/types/reranker.py`, `extractor.py`, `builtins/qwen3_reranker.py`

### Strengths

- Clean abstract base classes with clear interfaces
- Proper async support with `asyncio.to_thread()` for blocking operations
- `ExtractionResult` dataclass with comprehensive fields
- Good integration with existing VecPipe infrastructure

### Issues

#### 2.1 Potential Unbounded Growth in Extractor Instance Cache (HIGH)

**File:** `packages/webui/services/extractor_service.py`

The original report described an unbounded **result** cache; that code is not present. What *is* present is an unbounded cache of **extractor instances**, keyed by `(extractor_id, options-hash)` with no eviction:

```python
class ExtractorService:
    def __init__(self) -> None:
        self._extractor_instances: dict[str, ExtractorPlugin] = {}

    async def _get_extractor_instance(..., config: dict[str, Any] | None = None) -> ExtractorPlugin | None:
        config_hash = md5(json.dumps(config or {}, ...)).hexdigest()[:16]
        cache_key = f"{extractor_id}:{config_hash}"
        if cache_key in self._extractor_instances:
            return self._extractor_instances[cache_key]
        ...
        self._extractor_instances[cache_key] = instance
```

**Impact:** If callers can vary `options`/`config` arbitrarily (notably via the test endpoint), the cache can grow without bound over the process lifetime.

**Recommendation:** Bound the instance cache (LRU/TTL) and/or avoid treating per-call “options” as part of the instance identity unless truly required.

#### 2.2 Missing Input Size Limit in Test Endpoint (HIGH)

**File:** `packages/webui/api/v2/extractors.py`

Test extraction endpoint accepts raw text without a max length (current model uses `min_length=1` only).

**Recommendation:** Add input validation:
```python
class ExtractTestRequest(BaseModel):
    text: str = Field(..., min_length=1, max_length=100_000)  # example limit (100KB)
```

#### 2.3 Reranker Integration Bypass (NOT REPRODUCED)

**File:** `packages/webui/services/search_service.py`

On re-check, WebUI search does not instantiate `CrossEncoderReranker` directly. It resolves `reranker_id` to a model name via the plugin registry and delegates actual reranking to VecPipe.

#### 2.4 `Qwen3RerankerPlugin` Lazy-Init Race (NOT REPRODUCED)

**File:** `packages/shared/plugins/builtins/qwen3_reranker.py`

The current implementation uses a lock (`threading.Lock`) with double-checked loading and runs the blocking model load via `asyncio.to_thread()`.

---

## 3. Backend API Endpoints

**Files Reviewed:** `packages/webui/api/v2/plugins.py`, `extractors.py`, `rerankers.py`

### Strengths

- RESTful design with appropriate HTTP methods
- Admin-only install/uninstall with `is_superuser` check
- Proper error handling with consistent response format
- Support for health checks and configuration management

### Issues / Notes

#### 3.1 Missing Rate Limiting (NOT REPRODUCED)

**File:** `packages/webui/main.py`, `packages/webui/rate_limiter.py`, `packages/webui/api/v2/plugins.py`

On re-check, install/uninstall requests are covered by the app’s global SlowAPI limiter (default limit is `1000/hour`) via middleware and `app.state.limiter`.

**Recommendation (hardening):** Consider adding a stricter per-endpoint limit for install/uninstall since `pip install` is expensive (even if admin-only).

#### 3.2 Command Injection Risk (REPHRASED: Install Target Hardening) (MEDIUM)

**File:** `packages/webui/services/plugin_installer.py`

While `validation.py` validates inputs, the install command is passed to subprocess:
```python
def install_plugin(install_command: str, timeout: int = 300) -> tuple[bool, str]:
    result = subprocess.run(
        ["pip", "install", "--target", str(plugins_dir), "--upgrade",
         "--no-cache-dir", install_command],  # install_command from registry
        ...
    )
```

The call uses `subprocess.run([...])` (no shell), and current validation blocks whitespace and option-like targets. This makes classic shell command injection unlikely.

The real risk here is **what pip is allowed to install** if a registry entry is malicious or misconfigured (e.g., VCS URLs / local file URLs / unexpected schemes), i.e., supply-chain and “unexpected install source” risk rather than command injection.

**Recommendation:**
1. Tighten `validate_pip_install_target()` to accept only intended forms (e.g., PyPI requirement strings and `git+https://...`), and explicitly reject `file://` and local paths.
2. Consider allowlisting trusted registry sources and/or pinning known-good plugin refs/hashes.

#### 3.3 Uninstall “Not Installed” Response Shape (LOW)

The uninstall endpoint does not fail silently; the installer returns `(False, "... not found ...")` and the API returns `success=false`. If you prefer HTTP semantics, you could return a 404 when the package is not present.

### Missing Features

- No pagination on plugin list endpoints (could be slow with many plugins)
- No filtering/sorting options for available plugins
- No webhook notifications for plugin lifecycle events

---

## 4. Frontend Implementation

**Files Reviewed:** `apps/webui-react/src/components/plugins/`, `hooks/usePlugins.ts`, `types/plugin.ts`

### Strengths

- Comprehensive TypeScript types matching backend schemas
- React Query integration with proper query keys
- Good loading/error state handling
- Card-based UI with clear status indicators

### Issues / Notes

#### 4.1 Missing Error Boundaries (REPHRASED) (LOW)

The app is wrapped in an `ErrorBoundary` at the top level (`apps/webui-react/src/App.tsx`), so plugin UI failures should be caught rather than crashing the entire app.

**Recommendation:** If you want more targeted resilience, add a plugin-settings-scoped boundary so errors can be contained to that page/section with a better recovery UX.

#### 4.2 Memory Leak in Focus Management (NOT REPRODUCED)

**File:** `apps/webui-react/src/components/plugins/PluginConfigModal.tsx`

The current modal does not use `createFocusTrap()` and includes cleanup for restoring focus to the previously focused element. No leak was identified in the current code.

#### 4.3 Stale State After Mutation (NOT REPRODUCED)

**File:** `apps/webui-react/src/hooks/usePlugins.ts`

Enable/disable mutations already invalidate relevant React Query keys on success.

#### 4.4 Type Mismatch (NOT REPRODUCED)

**File:** `apps/webui-react/src/types/plugin.ts`

The reported mismatches (optional manifest version, etc.) do not match current frontend types.

### Missing Features

- No optimistic updates for enable/disable operations
- No virtualization for large plugin lists
- No keyboard navigation in plugin grid

---

## 5. Security Implementation

**Files Reviewed:** `packages/shared/plugins/security.py`, `validation.py`

### Strengths

- Appropriate cooperative security model (no sandboxing claims)
- Comprehensive audit logging with structured fields
- Sensitive environment variable filtering
- Input validation for plugin IDs, package names, git refs

### Issues / Notes

#### 5.1 State File Operations Aren’t Audit-Logged (LOW)

**File:** `packages/shared/plugins/state.py`

The state file helper (`write_state` / `read_state`) does not emit `audit_log()` events. However, plugin config changes and enable/disable operations are audited at the service/API layer, so the state file is largely a derived artifact.

**Recommendation:** Optional: add an audit log event at the call site that writes the state file (or add structured logs in `write_state` / `read_state`) if you want explicit traceability of persistence operations.

#### 5.2 Registry Fallback Isn’t Silent (NOT REPRODUCED), But Isn’t Audited Either (LOW)

**File:** `packages/shared/plugins/registry_client.py`

The current implementation logs when it falls back to the bundled registry. There is no explicit audit log event for that fallback.

**Recommendation:** Optional: add an audit event (or a structured log) when falling back, and consider a configuration toggle if you ever want “fail closed”.

#### 5.3 Broad Exception Handling (MEDIUM)

Multiple files catch `Exception` broadly:
```python
except Exception as e:
    logger.error(f"Plugin load failed: {e}")
```

**Impact:** Could mask security-relevant errors.

**Recommendation:** Catch specific exceptions, re-raise unexpected ones.

### Missing Validation Tests

The `validation.py` module is security-critical but has no dedicated tests:
- `validate_plugin_id()` - No tests for edge cases
- `validate_package_name()` - No tests for malicious inputs
- `validate_git_ref()` - No tests for injection attempts

**Recommendation:** Add comprehensive test suite for validation module.

---

## 6. Registry and Plugin Installation

**Files Reviewed:** `packages/shared/plugins/registry_client.py`, `packages/webui/services/plugin_installer.py`

### Strengths

- Caching with TTL for registry data
- Single-flight pattern prevents thundering herd
- Bundled registry fallback for offline operation
- Path traversal protection in uninstall

### Issues

#### 6.1 Install Target Scheme/Source Validation (HIGH)

**File:** `packages/shared/plugins/validation.py`

The current `validate_pip_install_target()` focuses on option-injection defense (no whitespace, no leading `-`, length cap). It does **not** constrain where pip can install from (e.g., it doesn’t explicitly reject `file://` or local paths).

**Impact:** If a registry entry is malicious or misconfigured, pip may be asked to install from unintended sources (local file URLs/paths, unexpected VCS schemes, etc.).

**Recommendation:** Tighten validation to explicitly allow only the supported install target shapes (e.g., PyPI requirement strings and `git+https://...`) and reject local paths/URLs.

#### 6.2 Version Append Logic Is String-Based (MEDIUM)

**File:** `packages/webui/api/v2/plugins.py`

Install endpoint builds `install_cmd` using string operations (strip `"pip install "`, append `@version` to git URLs, or `==version` to PyPI names). This is workable but can mishandle edge cases (extras, already-pinned specifiers, unusual VCS URL formats).

**Recommendation:** Parse/construct install targets more robustly (e.g., explicit handling for `git+https://...@ref`, and `packaging` for requirement strings).

#### 6.3 No Rollback Mechanism (MEDIUM)

Failed installations leave partial state:
```python
def install_plugin(install_command: str) -> tuple[bool, str]:
    result = subprocess.run(["pip", "install", ...])
    if result.returncode != 0:
        return False, result.stderr  # No cleanup of partial install
```

**Recommendation:** Track pre-install state, rollback on failure.

---

## 7. Database and Integration

**Files Reviewed:** `alembic/versions/202601011000_add_reranker_and_extraction_config.py`, search service integration

### Strengths

- Clean migration with nullable columns (no data migration needed)
- Appropriate column types (String for reranker_id, JSON for extraction_config)
- Foreign key relationships maintained

### Issues

#### 7.1 Missing JSON Validation (HIGH)

**File:** Migration and model

The `extraction_config` column accepts any JSON without schema validation:
```python
extraction_config = Column(JSON, nullable=True)  # No validation
```

**Impact:** Malformed config can cause runtime errors and inconsistent behavior (this is not a SQL injection vector in the current usage).

**Recommendation:** Validate `extraction_config` at the API boundary (and optionally via a model helper) using an explicit schema:
```python
from pydantic import BaseModel

class ExtractionConfig(BaseModel):
    enabled: bool = False
    extractor_ids: list[str] = []
    types: list[str] | None = None
    options: dict[str, Any] | None = None

    model_config = {"extra": "forbid"}
```

#### 7.2 Collection Default Reranker Not Used (MEDIUM)

**File:** `packages/webui/services/search_service.py`

The `default_reranker_id` column exists on the collection model, but search paths take `reranker_id` from the request and do not fall back to the collection’s default when the request omits it.

**Recommendation:** Fall back to collection's default reranker.

#### 7.3 “Silent” Extraction Failures (NOT REPRODUCED)

The current search service does not run extractors during search. Extraction happens during ingestion, and failures are logged as warnings while ingestion continues.

### Missing Constraints

- No check constraint on `default_reranker_id` format
- No validation that referenced reranker exists/is enabled
- No index on `extraction_config` for queries filtering by config

---

## 8. Documentation

**Files Reviewed:** `docs/PLUGIN_REGISTRY.md`, `PLUGIN_SECURITY.md`, `PLUGIN_TESTING.md`, `API_REFERENCE.md`, `PLUGIN_EXTENSIBILITY_ROADMAP.md`

### Strengths

- Comprehensive coverage of plugin system architecture
- Good security documentation with threat model
- API endpoints well-documented
- Testing framework documentation with examples

### Critical Issues

#### 8.1 Phase 7 Status Incorrect (CRITICAL)

**File:** `PLUGIN_EXTENSIBILITY_ROADMAP.md`

Phase 7 (In-App Installation) is marked as "Planned" but implementation exists and is functional.

**Recommendation:** Update status to COMPLETE.

#### 8.2 Version Inconsistencies (HIGH)

**File:** `packages/shared/plugins/data/registry.yaml`

**Status (as of re-check):** Updated/consistent — bundled registry entries now use `min_semantik_version: "0.7.5"` where present.

**Recommendation:** Keep registry data and docs/examples aligned to the actual Semantik version (`0.7.5`).

#### 8.3 `install_command` Documentation (ADDRESSED)

**File:** `docs/PLUGIN_REGISTRY.md`

**Status (as of re-check):** Updated/consistent — registry docs now include `install_command` and schema version examples align with the bundled registry (`registry_version: "1.1"`).

#### 8.4 Inaccurate `SENSITIVE_ENV_PATTERNS` List (MEDIUM)

**File:** `docs/PLUGIN_SECURITY.md`

Documentation lists 8 patterns but implementation has more:
- Missing from docs: `ACCESS`, `DATABASE_URL`, `DSN`, `PASS`, `PWD`, `REDIS_URL`

### Missing Documentation

- `PLUGIN_INSTALLATION.md` - No dedicated installation guide
- Plugin author migration guide
- Troubleshooting guide expansion

---

## 9. Frontend Test Quality

**Files Reviewed:** All `__tests__/` files under `apps/webui-react/src/components/plugins/`, `hooks/`, `services/api/v2/`

### Overall Grade: **B-**

### Strengths

- Comprehensive user interaction testing with `@testing-library/user-event`
- Good MSW integration for API mocking
- Clear test structure with logical `describe` blocks
- Proper async testing patterns with `waitFor`

### Critical Issues

#### 9.1 Over-Mocking (CRITICAL)

Hooks are mocked at module level, preventing real React Query integration testing:
```typescript
vi.mock('@/hooks/usePlugins', () => ({
  usePluginConfigSchema: vi.fn(),
  useUpdatePluginConfig: vi.fn(),
}));
```

**Impact:** Tests pass even when real hook implementations have bugs.

**Recommendation:** Use MSW to mock API responses instead of mocking hooks.

#### 9.2 Testing Implementation Details (CRITICAL)

Tests verify CSS classes rather than behavior:
```typescript
expect(card).toHaveClass('border-green-200');
expect(card).toHaveClass('bg-green-50');
```

**Recommendation:** Test accessibility attributes and semantic meaning instead.

#### 9.3 Insufficient Error Coverage (MEDIUM)

Missing error scenario tests for:
- API failures during enable/disable
- Install/uninstall failures
- Network timeouts
- Malformed plugin data

### Missing Test Categories

- Accessibility testing (keyboard navigation, screen readers)
- Race condition testing (concurrent operations)
- Large dataset performance testing
- Visual regression testing

---

## 10. Recommendations Summary

### Priority 1: Critical (Fix Before Release)

| Issue | Location | Recommendation |
|-------|----------|----------------|
| Potential unbounded extractor instance cache growth | `packages/webui/services/extractor_service.py` | Bound the instance cache (LRU/TTL) and avoid treating per-call options as instance identity unless required |
| Missing `extraction_config` schema/size validation | `packages/webui/api/schemas.py`, `packages/shared/database/models.py` | Validate shape at API boundary (Pydantic schema) and reject unexpected fields |
| Install target validation too permissive | `packages/shared/plugins/validation.py` | Restrict to supported pip targets (PyPI requirement strings + `git+https://...`) and reject local paths / `file://` |
| Extractor test endpoint missing max text length | `packages/webui/api/v2/extractors.py` | Add a `max_length` limit to request text |
| Phase 7 roadmap status drift | `PLUGIN_EXTENSIBILITY_ROADMAP.md` | Mark Phase 7 as COMPLETE (or adjust wording to match what shipped) |

### Priority 2: High (Fix Before GA)

| Issue | Location | Recommendation |
|-------|----------|----------------|
| No rollback/cleanup on failed installs | `packages/webui/services/plugin_installer.py` | Install into a temp dir then swap, or track/remove newly created paths on failure |
| Double-registration of built-ins via entry points | `packages/shared/plugins/loader.py` | Recompute missing types after built-ins, or split internal vs external entry point groups |
| Missing unit tests for validation helpers | `packages/shared/plugins/validation.py` | Add focused unit tests for `validate_*` helpers (edge cases + malicious inputs) |
| Security docs drift on env filtering patterns | `docs/PLUGIN_SECURITY.md` | Sync documented patterns with `SENSITIVE_ENV_PATTERNS` in code |

### Priority 3: Medium (Next Sprint)

| Issue | Location | Recommendation |
|-------|----------|----------------|
| Collection default reranker not used | `packages/webui/services/search_service.py` | When request omits `reranker_id`, fall back to `collection.default_reranker_id` |
| Add stricter per-endpoint limits for expensive ops | `packages/webui/api/v2/plugins.py` | Add explicit rate limit for install/uninstall (global limiter exists, but these are heavy) |
| Frontend tests over-mock hooks | `apps/webui-react/src/components/plugins/__tests__/` | Prefer MSW + real hooks for integration coverage |
| Frontend tests assert Tailwind classes | `apps/webui-react/src/components/plugins/__tests__/` | Assert semantic/accessible behavior instead of class names |

### Priority 4: Low (Technical Debt)

| Issue | Location | Recommendation |
|-------|----------|----------------|
| Uninstall “not installed” semantics | `packages/webui/api/v2/plugins.py` | Consider returning HTTP 404 instead of `success=false` |
| Pagination/sorting for plugin lists | API | Add pagination/sorting if registry/installed lists grow large |
| Keyboard navigation/virtualization | Frontend | Add keyboard support and list virtualization if needed |

### Findings Not Reproduced / Already Addressed (as of re-check)

- `PluginRegistry.list_records()` race condition (registry records are immutable snapshots)
- State file atomicity (temp file + atomic rename already in place)
- “Missing rate limiting” on install/uninstall (covered by global limiter defaults)
- Qwen3 reranker lazy-init race (uses locking + background thread load)
- WebUI search directly instantiating `CrossEncoderReranker` (not present; WebUI delegates reranking to VecPipe)
- Plugin modal focus-trap leak + stale React Query cache invalidation + type mismatches (not reproducible against current code)

---

## Appendix A: Files Changed Summary

### New Files (Core)
- `packages/shared/plugins/types/reranker.py`
- `packages/shared/plugins/types/extractor.py`
- `packages/shared/plugins/builtins/qwen3_reranker.py`
- `packages/shared/plugins/security.py`
- `packages/shared/plugins/validation.py`
- `packages/shared/plugins/registry_client.py`
- `packages/shared/plugins/testing/` (contracts, fixtures, mocks)

### New Files (API)
- `packages/webui/api/v2/plugins.py`
- `packages/webui/api/v2/extractors.py`
- `packages/webui/api/v2/rerankers.py`
- `packages/webui/services/plugin_installer.py`
- `packages/webui/services/extractor_service.py`

### New Files (Frontend)
- `apps/webui-react/src/components/plugins/` (6 components)
- `apps/webui-react/src/hooks/usePlugins.ts`
- `apps/webui-react/src/services/api/v2/plugins.ts`
- `apps/webui-react/src/types/plugin.ts`

### Modified Files
- `packages/shared/plugins/loader.py` (extended for new types)
- `packages/shared/plugins/registry.py` (thread safety improvements)
- `packages/webui/services/search_service.py` (reranker/extractor integration)
- `packages/shared/database/models.py` (new columns)

### Documentation
- `docs/PLUGIN_REGISTRY.md`
- `docs/PLUGIN_SECURITY.md`
- `docs/PLUGIN_TESTING.md`
- `docs/API_REFERENCE.md`
- `PLUGIN_EXTENSIBILITY_ROADMAP.md`

---

## Appendix B: Testing Recommendations

### Unit Tests Needed
1. `packages/shared/plugins/validation.py` - All validation functions
2. `packages/shared/plugins/state.py` - State persistence
3. `packages/shared/plugins/security.py` - Audit logging, env filtering

### Integration Tests Needed
1. Plugin installation end-to-end with rollback
2. Concurrent plugin loading
3. Registry client with network failures
4. Search with reranking and extraction

### Frontend Tests Needed
1. Error boundary behavior
2. Keyboard navigation
3. Race condition handling
4. Large plugin list performance

---

## Conclusion

The v0.7.5 plugin extensibility implementation represents a solid architectural foundation for Semantik's plugin ecosystem. The system is well-designed with appropriate abstractions and a realistic cooperative security model. After re-checking the current code, the main remaining concerns are **bounded caching** (extractor instance cache), **schema/size validation** for `extraction_config`, **tightening install target validation**, and **docs/test hardening**.

The recommended approach is to:
1. Fix all Priority 1 (Critical) issues immediately
2. Address Priority 2 (High) issues before GA release
3. Plan Priority 3 (Medium) issues for the next sprint
4. Track Priority 4 (Low) as technical debt

With these improvements, the plugin system will be production-ready and provide a robust foundation for community-contributed plugins.

---

*Report originally generated by automated multi-agent code review on January 2, 2026; updated after manual verification on January 2, 2026.*
