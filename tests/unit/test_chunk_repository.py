"""Unit tests for ChunkRepository with partition awareness."""

from datetime import UTC, datetime, timedelta
from unittest.mock import AsyncMock, MagicMock, Mock, patch
from uuid import uuid4

import pytest
from sqlalchemy.ext.asyncio import AsyncSession

from packages.shared.database.models import Chunk
from packages.shared.database.repositories.chunk_repository import ChunkRepository


class TestChunkRepository:
    """Test cases for ChunkRepository."""

    @pytest.fixture()
    def mock_session(self) -> None:
        """Create a mock async session."""
        session = AsyncMock(spec=AsyncSession)
        session.add = MagicMock()
        session.delete = MagicMock()
        session.flush = AsyncMock()
        session.execute = AsyncMock()
        session.scalar = AsyncMock()
        session.run_sync = AsyncMock()
        return session

    @pytest.fixture()
    def repository(self, mock_session) -> None:
        """Create a ChunkRepository instance with mocked session."""
        return ChunkRepository(mock_session)

    @pytest.fixture()
    def sample_chunk_data(self) -> None:
        """Create sample chunk data for testing."""
        return {
            # Note: id is auto-generated by database sequence, not included here
            "collection_id": str(uuid4()),
            "document_id": str(uuid4()),
            "chunk_index": 0,
            "content": "Test chunk content",
            "metadata": {"source": "test"},
            "embedding_vector_id": None,
        }

    @pytest.mark.asyncio()
    async def test_create_chunk_success(self, repository, mock_session, sample_chunk_data) -> None:
        """Test successful chunk creation."""
        result = await repository.create_chunk(sample_chunk_data)

        assert isinstance(result, Chunk)
        assert result.collection_id == sample_chunk_data["collection_id"].lower()
        assert result.content == sample_chunk_data["content"]
        mock_session.add.assert_called_once()
        mock_session.flush.assert_called_once()

    @pytest.mark.asyncio()
    async def test_create_chunk_auto_generate_id(self, repository, mock_session) -> None:
        """Test chunk creation with auto-generated ID."""
        chunk_data = {
            "collection_id": str(uuid4()),
            "content": "Test content",
        }

        result = await repository.create_chunk(chunk_data)

        # ID is auto-generated by database sequence as an integer
        # The model doesn't set an ID, it's handled by the database
        # So we just verify the Chunk object was created
        assert isinstance(result, Chunk)

    @pytest.mark.asyncio()
    async def test_create_chunk_missing_collection_id(self, repository) -> None:
        """Test chunk creation fails without collection_id."""
        chunk_data = {"content": "Test content"}

        with pytest.raises(ValueError, match="collection_id is required"):
            await repository.create_chunk(chunk_data)

    @pytest.mark.asyncio()
    async def test_create_chunk_invalid_collection_id(self, repository) -> None:
        """Test chunk creation with invalid collection_id."""
        chunk_data = {
            "collection_id": "not-a-uuid",
            "content": "Test content",
        }

        with pytest.raises(ValueError, match="must be a valid UUID"):
            await repository.create_chunk(chunk_data)

    @pytest.mark.asyncio()
    async def test_create_chunks_bulk_success(self, repository, mock_session) -> None:
        """Test successful bulk chunk creation."""
        chunks_data = [
            {
                "collection_id": str(uuid4()),
                "content": f"Chunk {i}",
                "chunk_index": i,
            }
            for i in range(5)
        ]

        # Mock the bulk insert behavior
        def mock_run_sync(func) -> None:
            sync_session = Mock()
            sync_session.bulk_insert_mappings = Mock()
            func(sync_session)

        mock_session.run_sync.side_effect = mock_run_sync

        count = await repository.create_chunks_bulk(chunks_data)

        assert count == 5
        assert mock_session.run_sync.called

    @pytest.mark.asyncio()
    async def test_create_chunks_bulk_empty_list(self, repository, mock_session) -> None:
        """Test bulk creation with empty list."""
        count = await repository.create_chunks_bulk([])

        assert count == 0
        mock_session.run_sync.assert_not_called()

    @pytest.mark.asyncio()
    async def test_create_chunks_bulk_auto_generate_ids(self, repository, mock_session) -> None:
        """Test bulk creation auto-generates IDs."""
        chunks_data = [
            {"collection_id": str(uuid4()), "content": "Chunk 1"},
            {"collection_id": str(uuid4()), "content": "Chunk 2"},
        ]

        # Mock the bulk insert
        inserted_data = []

        def capture_bulk_insert(func) -> None:
            sync_session = Mock()
            sync_session.bulk_insert_mappings = Mock(side_effect=lambda _model, items: inserted_data.extend(items))
            func(sync_session)

        mock_session.run_sync.side_effect = capture_bulk_insert

        await repository.create_chunks_bulk(chunks_data)

        # IDs are not included in bulk insert data - they're generated by database sequence
        # So we verify the data was prepared correctly for insertion
        assert len(inserted_data) == 2

    @pytest.mark.asyncio()
    async def test_get_chunk_by_id_found(self, repository, mock_session, sample_chunk_data) -> None:
        """Test getting chunk by ID when it exists."""
        # Add an integer ID for the test
        sample_chunk_data["id"] = 12345
        chunk = Chunk(**sample_chunk_data)
        mock_result = Mock()
        mock_result.scalar_one_or_none.return_value = chunk
        mock_session.execute.return_value = mock_result

        result = await repository.get_chunk_by_id(12345, sample_chunk_data["collection_id"])

        assert result == chunk
        mock_session.execute.assert_called_once()

    @pytest.mark.asyncio()
    async def test_get_chunk_by_id_not_found(self, repository, mock_session) -> None:
        """Test getting chunk by ID when it doesn't exist."""
        mock_result = Mock()
        mock_result.scalar_one_or_none.return_value = None
        mock_session.execute.return_value = mock_result

        result = await repository.get_chunk_by_id(99999, str(uuid4()))

        assert result is None

    @pytest.mark.asyncio()
    async def test_get_chunk_by_id_invalid_ids(self, repository) -> None:
        """Test getting chunk with invalid IDs."""
        # chunk_id should be an integer
        with pytest.raises(TypeError, match="chunk_id must be an integer"):
            await repository.get_chunk_by_id("invalid-id", str(uuid4()))

        # collection_id should be a valid UUID
        with pytest.raises(ValueError, match="must be a valid UUID"):
            await repository.get_chunk_by_id(12345, "invalid-collection-id")

    @pytest.mark.asyncio()
    async def test_get_chunks_by_document(self, repository, mock_session) -> None:
        """Test getting chunks by document ID."""
        doc_id = str(uuid4())
        collection_id = str(uuid4())

        chunks = [
            Chunk(
                id=1000 + i,  # Integer IDs
                collection_id=collection_id,
                document_id=doc_id,
                chunk_index=i,
                content=f"Chunk {i}",
            )
            for i in range(3)
        ]

        mock_result = Mock()
        mock_result.scalars.return_value.all.return_value = chunks
        mock_session.execute.return_value = mock_result

        result = await repository.get_chunks_by_document(doc_id, collection_id)

        assert len(result) == 3
        assert all(chunk.document_id == doc_id for chunk in result)

    @pytest.mark.asyncio()
    async def test_get_chunks_by_document_with_pagination(self, repository, mock_session) -> None:
        """Test getting chunks with limit and offset."""
        mock_result = Mock()
        mock_result.scalars.return_value.all.return_value = []
        mock_session.execute.return_value = mock_result

        await repository.get_chunks_by_document(str(uuid4()), str(uuid4()), limit=10, offset=20)

        # Verify query was executed (pagination is handled in SQL)
        mock_session.execute.assert_called_once()

    @pytest.mark.asyncio()
    async def test_get_chunks_by_document_invalid_pagination(self, repository) -> None:
        """Test getting chunks with invalid pagination parameters."""
        doc_id = str(uuid4())
        collection_id = str(uuid4())

        with pytest.raises(ValueError, match="offset must be non-negative"):
            await repository.get_chunks_by_document(doc_id, collection_id, offset=-1)

        with pytest.raises(ValueError, match="limit must be non-negative"):
            await repository.get_chunks_by_document(doc_id, collection_id, limit=-1)

    @pytest.mark.asyncio()
    async def test_get_chunks_by_collection(self, repository, mock_session) -> None:
        """Test getting all chunks for a collection."""
        collection_id = str(uuid4())
        created_after = datetime.now(UTC) - timedelta(days=1)

        chunks = [
            Chunk(
                id=2000 + i,  # Integer IDs
                collection_id=collection_id,
                content=f"Chunk {i}",
                created_at=datetime.now(UTC),
            )
            for i in range(5)
        ]

        mock_result = Mock()
        mock_result.scalars.return_value.all.return_value = chunks
        mock_session.execute.return_value = mock_result

        result = await repository.get_chunks_by_collection(collection_id, limit=10, created_after=created_after)

        assert len(result) == 5

    @pytest.mark.asyncio()
    async def test_update_chunk_embeddings_success(self, repository, mock_session) -> None:
        """Test updating chunk embeddings successfully."""
        collection_id = str(uuid4())
        chunk_updates = [
            {
                "id": 3000 + i,  # Integer IDs
                "collection_id": collection_id,
                "embedding_vector_id": str(uuid4()),
            }
            for i in range(3)
        ]

        # Mock update execution
        mock_result = Mock()
        mock_result.rowcount = 1
        mock_session.execute.return_value = mock_result

        count = await repository.update_chunk_embeddings(chunk_updates)

        assert count == 3
        assert mock_session.execute.call_count == 3

    @pytest.mark.asyncio()
    async def test_update_chunk_embeddings_empty_list(self, repository, mock_session) -> None:
        """Test updating embeddings with empty list."""
        count = await repository.update_chunk_embeddings([])

        assert count == 0
        mock_session.execute.assert_not_called()

    @pytest.mark.asyncio()
    async def test_update_chunk_embeddings_invalid_data(self, repository) -> None:
        """Test updating embeddings with invalid data."""
        # Missing required field
        with pytest.raises(ValueError, match="must have 'id', 'collection_id', and 'embedding_vector_id'"):
            await repository.update_chunk_embeddings([{"id": 12345}])

        # Wrong type
        with pytest.raises(TypeError, match="Each chunk update must be a dictionary"):
            await repository.update_chunk_embeddings(["not a dict"])

        # Invalid chunk ID type
        with pytest.raises(TypeError, match="chunk id must be an integer"):
            await repository.update_chunk_embeddings(
                [
                    {
                        "id": "invalid",
                        "collection_id": str(uuid4()),
                        "embedding_vector_id": str(uuid4()),
                    }
                ]
            )

    @pytest.mark.asyncio()
    async def test_update_chunk_embeddings_batch_size_limit(self, repository) -> None:
        """Test updating embeddings exceeds batch size limit."""
        # Create more updates than allowed
        chunk_updates = [
            {
                "id": 10000 + i,  # Integer IDs
                "collection_id": str(uuid4()),
                "embedding_vector_id": str(uuid4()),
            }
            for i in range(10001)  # Exceeds MAX_BATCH_SIZE
        ]

        with pytest.raises(ValueError, match="batch size .* exceeds maximum allowed"):
            await repository.update_chunk_embeddings(chunk_updates)

    @pytest.mark.asyncio()
    async def test_delete_chunks_by_document(self, repository, mock_session) -> None:
        """Test deleting chunks by document ID."""
        mock_result = Mock()
        mock_result.rowcount = 5
        mock_session.execute.return_value = mock_result

        count = await repository.delete_chunks_by_document(str(uuid4()), str(uuid4()))

        assert count == 5
        mock_session.execute.assert_called_once()

    @pytest.mark.asyncio()
    async def test_delete_chunks_by_collection(self, repository, mock_session) -> None:
        """Test deleting all chunks for a collection."""
        mock_result = Mock()
        mock_result.rowcount = 100
        mock_session.execute.return_value = mock_result

        count = await repository.delete_chunks_by_collection(str(uuid4()))

        assert count == 100
        mock_session.execute.assert_called_once()

    @pytest.mark.asyncio()
    async def test_get_chunk_statistics(self, repository, mock_session) -> None:
        """Test getting chunk statistics delegates to helper."""
        collection_id = str(uuid4())

        with patch("packages.shared.database.repositories.chunk_repository.ChunkPartitionHelper") as mock_helper:
            mock_stats = {
                "collection_id": collection_id,
                "chunk_count": 50,
                "avg_content_length": 250.5,
            }
            mock_helper.get_partition_statistics = AsyncMock(return_value=mock_stats)

            result = await repository.get_chunk_statistics(collection_id)

            assert result == mock_stats
            mock_helper.get_partition_statistics.assert_called_once_with(mock_session, collection_id)

    @pytest.mark.asyncio()
    async def test_count_chunks_by_document(self, repository, mock_session) -> None:
        """Test counting chunks for a document."""
        mock_result = Mock()
        mock_result.scalar.return_value = 10
        mock_session.execute.return_value = mock_result

        count = await repository.count_chunks_by_document(str(uuid4()), str(uuid4()))

        assert count == 10

    @pytest.mark.asyncio()
    async def test_count_chunks_by_document_none_result(self, repository, mock_session) -> None:
        """Test counting chunks returns 0 for None result."""
        mock_result = Mock()
        mock_result.scalar.return_value = None
        mock_session.execute.return_value = mock_result

        count = await repository.count_chunks_by_document(str(uuid4()), str(uuid4()))

        assert count == 0

    @pytest.mark.asyncio()
    async def test_get_chunks_without_embeddings(self, repository, mock_session) -> None:
        """Test getting chunks that need embeddings."""
        collection_id = str(uuid4())
        chunks = [
            Chunk(
                id=5000 + i,  # Integer IDs
                collection_id=collection_id,
                content=f"Chunk {i}",
                embedding_vector_id=None,
            )
            for i in range(5)
        ]

        mock_result = Mock()
        mock_result.scalars.return_value.all.return_value = chunks
        mock_session.execute.return_value = mock_result

        result = await repository.get_chunks_without_embeddings(collection_id, limit=10)

        assert len(result) == 5
        assert all(chunk.embedding_vector_id is None for chunk in result)

    @pytest.mark.asyncio()
    async def test_chunk_exists_true(self, repository, mock_session) -> None:
        """Test checking if chunk exists returns True."""
        mock_result = Mock()
        mock_result.scalar.return_value = 1
        mock_session.execute.return_value = mock_result

        exists = await repository.chunk_exists(str(uuid4()), str(uuid4()), 0)

        assert exists is True

    @pytest.mark.asyncio()
    async def test_chunk_exists_false(self, repository, mock_session) -> None:
        """Test checking if chunk exists returns False."""
        mock_result = Mock()
        mock_result.scalar.return_value = 0
        mock_session.execute.return_value = mock_result

        exists = await repository.chunk_exists(str(uuid4()), str(uuid4()), 0)

        assert exists is False
